"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/NeuralNetwork.tsx":
/*!**************************************!*\
  !*** ./components/NeuralNetwork.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ NeuralNetwork)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n// Generate fixed neuron positions using deterministic algorithm\nconst generateNeurons = (countOverride)=>{\n    const neurons = [];\n    const gridSize = 12; // Increased for wider spread\n    const spread = 10; // Adjusted spacing\n    const total = typeof countOverride === 'number' ? countOverride : 30; // More neurons for wider coverage\n    for(let i = 0; i < total; i++){\n        const gridX = i % gridSize * spread + Math.floor(i / gridSize) % 2 * (spread / 2);\n        const gridY = Math.floor(i / gridSize) * spread;\n        // Add some deterministic variation\n        const offsetX = i * 13 % 7 - 3;\n        const offsetY = i * 17 % 5 - 2;\n        neurons.push({\n            id: i,\n            x: 5 + gridX + offsetX,\n            y: 25 + gridY + offsetY,\n            connections: [],\n            pulseDelay: i * 0.3 % 4\n        });\n    }\n    // Create connections between nearby neurons\n    neurons.forEach((neuron, i)=>{\n        neurons.forEach((other, j)=>{\n            if (i !== j) {\n                const distance = Math.sqrt(Math.pow(neuron.x - other.x, 2) + Math.pow(neuron.y - other.y, 2));\n                if (distance < 20 && neuron.connections.length < 2) {\n                    neuron.connections.push(j);\n                }\n            }\n        });\n    });\n    return neurons;\n};\nfunction NeuralNetwork() {\n    var _containerRef_current, _containerRef_current1;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [mousePos, setMousePos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 50,\n        y: 50\n    });\n    const [isMounted, setIsMounted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [activeNeuron, setActiveNeuron] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [pulses, setPulses] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const isCoarsePointer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"NeuralNetwork.useMemo[isCoarsePointer]\": ()=> true && window.matchMedia && window.matchMedia('(pointer: coarse)').matches\n    }[\"NeuralNetwork.useMemo[isCoarsePointer]\"], []);\n    const prefersReducedMotion = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"NeuralNetwork.useMemo[prefersReducedMotion]\": ()=> true && window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches\n    }[\"NeuralNetwork.useMemo[prefersReducedMotion]\"], []);\n    const neurons = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"NeuralNetwork.useMemo[neurons]\": ()=>generateNeurons(isCoarsePointer || prefersReducedMotion ? 20 : 30)\n    }[\"NeuralNetwork.useMemo[neurons]\"], [\n        isCoarsePointer,\n        prefersReducedMotion\n    ]);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NeuralNetwork.useEffect\": ()=>{\n            setIsMounted(true);\n        }\n    }[\"NeuralNetwork.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NeuralNetwork.useEffect\": ()=>{\n            if (!isMounted || prefersReducedMotion) return;\n            const handleMouseMove = {\n                \"NeuralNetwork.useEffect.handleMouseMove\": (e)=>{\n                    if (containerRef.current) {\n                        const rect = containerRef.current.getBoundingClientRect();\n                        const x = (e.clientX - rect.left) / rect.width * 100;\n                        const y = (e.clientY - rect.top) / rect.height * 100;\n                        setMousePos({\n                            x,\n                            y\n                        });\n                        if (!isCoarsePointer) {\n                            // Find nearest neuron to mouse\n                            let nearestNeuron = null;\n                            let minDistance = 16; // increase capture radius slightly\n                            neurons.forEach({\n                                \"NeuralNetwork.useEffect.handleMouseMove\": (neuron)=>{\n                                    const distance = Math.sqrt(Math.pow(x - neuron.x, 2) + Math.pow(y - neuron.y, 2));\n                                    if (distance < minDistance) {\n                                        minDistance = distance;\n                                        nearestNeuron = neuron.id;\n                                    }\n                                }\n                            }[\"NeuralNetwork.useEffect.handleMouseMove\"]);\n                            setActiveNeuron(nearestNeuron);\n                        }\n                    }\n                }\n            }[\"NeuralNetwork.useEffect.handleMouseMove\"];\n            const onMouseLeave = {\n                \"NeuralNetwork.useEffect.onMouseLeave\": ()=>setActiveNeuron(null)\n            }[\"NeuralNetwork.useEffect.onMouseLeave\"];\n            const container = containerRef.current;\n            if (container) {\n                container.addEventListener(\"mousemove\", handleMouseMove);\n                container.addEventListener(\"mouseleave\", onMouseLeave);\n            }\n            return ({\n                \"NeuralNetwork.useEffect\": ()=>{\n                    if (container) {\n                        container.removeEventListener(\"mousemove\", handleMouseMove);\n                        container.removeEventListener(\"mouseleave\", onMouseLeave);\n                    }\n                }\n            })[\"NeuralNetwork.useEffect\"];\n        }\n    }[\"NeuralNetwork.useEffect\"], [\n        isMounted,\n        neurons,\n        isCoarsePointer,\n        prefersReducedMotion\n    ]);\n    // Animate pulses along connections\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NeuralNetwork.useEffect\": ()=>{\n            if (!isMounted || prefersReducedMotion) return;\n            let lastSpawn = 0;\n            const spawnInterval = isCoarsePointer ? 1600 : 1200; // slower firing by default\n            const maxPulses = isCoarsePointer ? 4 : 6; // fewer concurrent pulses\n            const animatePulses = {\n                \"NeuralNetwork.useEffect.animatePulses\": ()=>{\n                    const now = Date.now();\n                    // Add new pulses with throttling\n                    if (now - lastSpawn > spawnInterval && pulses.length < maxPulses) {\n                        lastSpawn = now;\n                        const randomNeuron = neurons[Math.floor(Math.random() * neurons.length)];\n                        if (randomNeuron.connections.length > 0) {\n                            const targetId = randomNeuron.connections[Math.floor(Math.random() * randomNeuron.connections.length)];\n                            setPulses({\n                                \"NeuralNetwork.useEffect.animatePulses\": (prev)=>[\n                                        ...prev,\n                                        {\n                                            id: \"\".concat(randomNeuron.id, \"-\").concat(targetId, \"-\").concat(now),\n                                            from: randomNeuron.id,\n                                            to: targetId,\n                                            progress: 0,\n                                            startTime: now\n                                        }\n                                    ]\n                            }[\"NeuralNetwork.useEffect.animatePulses\"]);\n                        }\n                    }\n                    // Update existing pulses\n                    setPulses({\n                        \"NeuralNetwork.useEffect.animatePulses\": (prev)=>prev.map({\n                                \"NeuralNetwork.useEffect.animatePulses\": (pulse)=>({\n                                        ...pulse,\n                                        progress: Math.min((now - pulse.startTime) / 1100, 1)\n                                    })\n                            }[\"NeuralNetwork.useEffect.animatePulses\"]).filter({\n                                \"NeuralNetwork.useEffect.animatePulses\": (pulse)=>pulse.progress < 1\n                            }[\"NeuralNetwork.useEffect.animatePulses\"])\n                    }[\"NeuralNetwork.useEffect.animatePulses\"]);\n                    animationRef.current = requestAnimationFrame(animatePulses);\n                }\n            }[\"NeuralNetwork.useEffect.animatePulses\"];\n            animationRef.current = requestAnimationFrame(animatePulses);\n            return ({\n                \"NeuralNetwork.useEffect\": ()=>{\n                    if (animationRef.current) {\n                        cancelAnimationFrame(animationRef.current);\n                    }\n                }\n            })[\"NeuralNetwork.useEffect\"];\n        }\n    }[\"NeuralNetwork.useEffect\"], [\n        isMounted,\n        neurons,\n        pulses.length,\n        isCoarsePointer,\n        prefersReducedMotion\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NeuralNetwork.useEffect\": ()=>{\n            // Pause animation and effects when tab is hidden\n            const handleVisibility = {\n                \"NeuralNetwork.useEffect.handleVisibility\": ()=>{\n                    if (document.hidden && animationRef.current) {\n                        cancelAnimationFrame(animationRef.current);\n                    } else if (!prefersReducedMotion) {\n                        animationRef.current = requestAnimationFrame({\n                            \"NeuralNetwork.useEffect.handleVisibility\": ()=>{}\n                        }[\"NeuralNetwork.useEffect.handleVisibility\"]);\n                    }\n                }\n            }[\"NeuralNetwork.useEffect.handleVisibility\"];\n            document.addEventListener('visibilitychange', handleVisibility);\n            return ({\n                \"NeuralNetwork.useEffect\": ()=>document.removeEventListener('visibilitychange', handleVisibility)\n            })[\"NeuralNetwork.useEffect\"];\n        }\n    }[\"NeuralNetwork.useEffect\"], [\n        prefersReducedMotion\n    ]);\n    const getConnectionOpacity = (from, to)=>{\n        if (activeNeuron === from || activeNeuron === to) return 0.75;\n        return 0.08;\n    };\n    const getNeuronScale = (neuronId)=>{\n        var _neurons_activeNeuron;\n        if (activeNeuron === neuronId) return 1.35;\n        if (activeNeuron !== null && ((_neurons_activeNeuron = neurons[activeNeuron]) === null || _neurons_activeNeuron === void 0 ? void 0 : _neurons_activeNeuron.connections.includes(neuronId))) return 1.15;\n        return 1;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"absolute inset-0 overflow-hidden\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 bg-gradient-to-tr from-indigo-950/10 via-transparent to-purple-950/10\"\n            }, void 0, false, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 205,\n                columnNumber: 7\n            }, this),\n            isMounted && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0\",\n                style: {\n                    filter: 'blur(0.5px)'\n                }\n            }, void 0, false, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 209,\n                columnNumber: 9\n            }, this),\n            isMounted && !prefersReducedMotion && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                className: \"absolute inset-0 w-full h-full\",\n                children: [\n                    neurons.map((neuron)=>neuron.connections.map((targetId)=>{\n                            const target = neurons[targetId];\n                            if (!target) return null;\n                            const isActive = activeNeuron === neuron.id || activeNeuron === targetId;\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.line, {\n                                x1: \"\".concat(neuron.x, \"%\"),\n                                y1: \"\".concat(neuron.y, \"%\"),\n                                x2: \"\".concat(target.x, \"%\"),\n                                y2: \"\".concat(target.y, \"%\"),\n                                stroke: \"rgba(99, 102, 241, 0.2)\",\n                                strokeWidth: 0.35,\n                                initial: {\n                                    opacity: 0\n                                },\n                                animate: {\n                                    opacity: getConnectionOpacity(neuron.id, targetId),\n                                    stroke: isActive ? \"rgba(139, 92, 246, 0.7)\" : \"rgba(99, 102, 241, 0.2)\",\n                                    strokeWidth: isActive ? 0.7 : 0.35\n                                },\n                                transition: {\n                                    duration: 0.2\n                                }\n                            }, \"\".concat(neuron.id, \"-\").concat(targetId), false, {\n                                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                lineNumber: 224,\n                                columnNumber: 17\n                            }, this);\n                        })),\n                    pulses.map((pulse)=>{\n                        const from = neurons[pulse.from];\n                        const to = neurons[pulse.to];\n                        if (!from || !to) return null;\n                        const x = from.x + (to.x - from.x) * pulse.progress;\n                        const y = from.y + (to.y - from.y) * pulse.progress;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                            cx: \"\".concat(x, \"%\"),\n                            cy: \"\".concat(y, \"%\"),\n                            r: \"1.8\",\n                            fill: \"rgba(168, 85, 247, 0.75)\",\n                            opacity: 1 - pulse.progress * 0.5,\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"animate\", {\n                                attributeName: \"r\",\n                                values: \"1.8;3;1.8\",\n                                dur: \"0.6s\",\n                                repeatCount: \"indefinite\"\n                            }, void 0, false, {\n                                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                lineNumber: 264,\n                                columnNumber: 17\n                            }, this)\n                        }, pulse.id, false, {\n                            fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                            lineNumber: 256,\n                            columnNumber: 15\n                        }, this);\n                    }),\n                    neurons.map((neuron)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.g, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.circle, {\n                                    cx: \"\".concat(neuron.x, \"%\"),\n                                    cy: \"\".concat(neuron.y, \"%\"),\n                                    r: \"7\",\n                                    fill: \"rgba(139, 92, 246, 0.08)\",\n                                    initial: {\n                                        scale: 0\n                                    },\n                                    animate: {\n                                        scale: getNeuronScale(neuron.id),\n                                        opacity: activeNeuron === neuron.id ? 0.25 : 0.08\n                                    },\n                                    transition: {\n                                        duration: 0.3\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                    lineNumber: 278,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.circle, {\n                                    cx: \"\".concat(neuron.x, \"%\"),\n                                    cy: \"\".concat(neuron.y, \"%\"),\n                                    r: \"2.6\",\n                                    fill: \"rgba(99, 102, 241, 0.45)\",\n                                    initial: {\n                                        scale: 0\n                                    },\n                                    animate: {\n                                        scale: getNeuronScale(neuron.id),\n                                        fill: activeNeuron === neuron.id ? \"rgba(168, 85, 247, 0.75)\" : \"rgba(99, 102, 241, 0.45)\"\n                                    },\n                                    transition: {\n                                        duration: 0.3,\n                                        delay: neuron.pulseDelay\n                                    },\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"animate\", {\n                                        attributeName: \"opacity\",\n                                        values: \"0.5;0.75;0.5\",\n                                        dur: \"\".concat(3 + neuron.pulseDelay, \"s\"),\n                                        repeatCount: \"indefinite\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                        lineNumber: 309,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                    lineNumber: 292,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: \"\".concat(neuron.x, \"%\"),\n                                    cy: \"\".concat(neuron.y, \"%\"),\n                                    r: \"0.9\",\n                                    fill: \"rgba(255, 255, 255, 0.8)\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                    lineNumber: 318,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, neuron.id, true, {\n                            fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                            lineNumber: 276,\n                            columnNumber: 13\n                        }, this))\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 214,\n                columnNumber: 9\n            }, this),\n            isMounted && !prefersReducedMotion && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.div, {\n                className: \"absolute w-64 h-64 rounded-full pointer-events-none\",\n                animate: {\n                    x: mousePos.x * (((_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.offsetWidth) || 0) / 100 - 128,\n                    y: mousePos.y * (((_containerRef_current1 = containerRef.current) === null || _containerRef_current1 === void 0 ? void 0 : _containerRef_current1.offsetHeight) || 0) / 100 - 128\n                },\n                transition: {\n                    type: \"spring\",\n                    damping: 30,\n                    stiffness: 200\n                },\n                style: {\n                    background: \"radial-gradient(circle, rgba(139, 92, 246, 0.08) 0%, transparent 70%)\",\n                    filter: \"blur(40px)\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 331,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute bottom-0 left-0 right-0 h-32 bg-gradient-to-t from-slate-950 to-transparent\"\n            }, void 0, false, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 350,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-0 left-0 right-0 h-24 bg-gradient-to-b from-slate-950 to-transparent\"\n            }, void 0, false, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 351,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n        lineNumber: 203,\n        columnNumber: 5\n    }, this);\n}\n_s(NeuralNetwork, \"kJlSeec+ia4vUa9stf33bQsSW1A=\");\n_c = NeuralNetwork;\nvar _c;\n$RefreshReg$(_c, \"NeuralNetwork\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTmV1cmFsTmV0d29yay50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUU2RDtBQUN0QjtBQWtCdkMsZ0VBQWdFO0FBQ2hFLE1BQU1LLGtCQUFrQixDQUFDQztJQUN2QixNQUFNQyxVQUFvQixFQUFFO0lBQzVCLE1BQU1DLFdBQVcsSUFBSSw2QkFBNkI7SUFDbEQsTUFBTUMsU0FBUyxJQUFJLG1CQUFtQjtJQUV0QyxNQUFNQyxRQUFRLE9BQU9KLGtCQUFrQixXQUFXQSxnQkFBZ0IsSUFBSSxrQ0FBa0M7SUFFeEcsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlELE9BQU9DLElBQUs7UUFDOUIsTUFBTUMsUUFBUSxJQUFLSixXQUFZQyxTQUFTLEtBQU1LLEtBQUssQ0FBQ0gsSUFBSUgsWUFBWSxJQUFNQyxDQUFBQSxTQUFTO1FBQ25GLE1BQU1NLFFBQVFGLEtBQUtDLEtBQUssQ0FBQ0gsSUFBSUgsWUFBWUM7UUFFekMsbUNBQW1DO1FBQ25DLE1BQU1PLFVBQVUsSUFBTSxLQUFNLElBQUs7UUFDakMsTUFBTUMsVUFBVSxJQUFNLEtBQU0sSUFBSztRQUVqQ1YsUUFBUVcsSUFBSSxDQUFDO1lBQ1hDLElBQUlSO1lBQ0pTLEdBQUcsSUFBSVIsUUFBUUk7WUFDZkssR0FBRyxLQUFLTixRQUFRRTtZQUNoQkssYUFBYSxFQUFFO1lBQ2ZDLFlBQVksSUFBSyxNQUFPO1FBQzFCO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUNoQixRQUFRaUIsT0FBTyxDQUFDLENBQUNDLFFBQVFkO1FBQ3ZCSixRQUFRaUIsT0FBTyxDQUFDLENBQUNFLE9BQU9DO1lBQ3RCLElBQUloQixNQUFNZ0IsR0FBRztnQkFDWCxNQUFNQyxXQUFXZixLQUFLZ0IsSUFBSSxDQUN4QmhCLEtBQUtpQixHQUFHLENBQUNMLE9BQU9MLENBQUMsR0FBR00sTUFBTU4sQ0FBQyxFQUFFLEtBQUtQLEtBQUtpQixHQUFHLENBQUNMLE9BQU9KLENBQUMsR0FBR0ss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Q0FmLFlBQVk7b0JBQ1ZnQixNQUFNO29CQUNOQyxTQUFTO29CQUNUQyxXQUFXO2dCQUNiO2dCQUNBaEMsT0FBTztvQkFDTGlDLFlBQVk7b0JBQ1o5QyxRQUFRO2dCQUNWOzs7Ozs7MEJBS0osOERBQUNVO2dCQUFJRSxXQUFVOzs7Ozs7MEJBQ2YsOERBQUNGO2dCQUFJRSxXQUFVOzs7Ozs7Ozs7Ozs7QUFHckI7R0FsU3dCOUQ7S0FBQUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lcmFuZG11bGxhL2lsbWNvcmUvY29tcG9uZW50cy9OZXVyYWxOZXR3b3JrLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBtb3Rpb24gfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiO1xuXG5pbnRlcmZhY2UgTmV1cm9uIHtcbiAgaWQ6IG51bWJlcjtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGNvbm5lY3Rpb25zOiBudW1iZXJbXTtcbiAgcHVsc2VEZWxheTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgUHVsc2Uge1xuICBpZDogc3RyaW5nO1xuICBmcm9tOiBudW1iZXI7XG4gIHRvOiBudW1iZXI7XG4gIHByb2dyZXNzOiBudW1iZXI7XG4gIHN0YXJ0VGltZTogbnVtYmVyO1xufVxuXG4vLyBHZW5lcmF0ZSBmaXhlZCBuZXVyb24gcG9zaXRpb25zIHVzaW5nIGRldGVybWluaXN0aWMgYWxnb3JpdGhtXG5jb25zdCBnZW5lcmF0ZU5ldXJvbnMgPSAoY291bnRPdmVycmlkZT86IG51bWJlcik6IE5ldXJvbltdID0+IHtcbiAgY29uc3QgbmV1cm9uczogTmV1cm9uW10gPSBbXTtcbiAgY29uc3QgZ3JpZFNpemUgPSAxMjsgLy8gSW5jcmVhc2VkIGZvciB3aWRlciBzcHJlYWRcbiAgY29uc3Qgc3ByZWFkID0gMTA7IC8vIEFkanVzdGVkIHNwYWNpbmdcblxuICBjb25zdCB0b3RhbCA9IHR5cGVvZiBjb3VudE92ZXJyaWRlID09PSAnbnVtYmVyJyA/IGNvdW50T3ZlcnJpZGUgOiAzMDsgLy8gTW9yZSBuZXVyb25zIGZvciB3aWRlciBjb3ZlcmFnZVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgIGNvbnN0IGdyaWRYID0gKGkgJSBncmlkU2l6ZSkgKiBzcHJlYWQgKyAoTWF0aC5mbG9vcihpIC8gZ3JpZFNpemUpICUgMikgKiAoc3ByZWFkIC8gMik7XG4gICAgY29uc3QgZ3JpZFkgPSBNYXRoLmZsb29yKGkgLyBncmlkU2l6ZSkgKiBzcHJlYWQ7XG5cbiAgICAvLyBBZGQgc29tZSBkZXRlcm1pbmlzdGljIHZhcmlhdGlvblxuICAgIGNvbnN0IG9mZnNldFggPSAoKGkgKiAxMykgJSA3KSAtIDM7XG4gICAgY29uc3Qgb2Zmc2V0WSA9ICgoaSAqIDE3KSAlIDUpIC0gMjtcblxuICAgIG5ldXJvbnMucHVzaCh7XG4gICAgICBpZDogaSxcbiAgICAgIHg6IDUgKyBncmlkWCArIG9mZnNldFgsIC8vIFJlZHVjZWQgbGVmdCBtYXJnaW4gZm9yIHdpZGVyIHNwcmVhZFxuICAgICAgeTogMjUgKyBncmlkWSArIG9mZnNldFksIC8vIEFkanVzdGVkIHZlcnRpY2FsIHBvc2l0aW9uaW5nXG4gICAgICBjb25uZWN0aW9uczogW10sXG4gICAgICBwdWxzZURlbGF5OiAoaSAqIDAuMykgJSA0LFxuICAgIH0pO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGNvbm5lY3Rpb25zIGJldHdlZW4gbmVhcmJ5IG5ldXJvbnNcbiAgbmV1cm9ucy5mb3JFYWNoKChuZXVyb24sIGkpID0+IHtcbiAgICBuZXVyb25zLmZvckVhY2goKG90aGVyLCBqKSA9PiB7XG4gICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChcbiAgICAgICAgICBNYXRoLnBvdyhuZXVyb24ueCAtIG90aGVyLngsIDIpICsgTWF0aC5wb3cobmV1cm9uLnkgLSBvdGhlci55LCAyKVxuICAgICAgICApO1xuICAgICAgICBpZiAoZGlzdGFuY2UgPCAyMCAmJiBuZXVyb24uY29ubmVjdGlvbnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIG5ldXJvbi5jb25uZWN0aW9ucy5wdXNoKGopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBuZXVyb25zO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTmV1cmFsTmV0d29yaygpIHtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgW21vdXNlUG9zLCBzZXRNb3VzZVBvc10gPSB1c2VTdGF0ZSh7IHg6IDUwLCB5OiA1MCB9KTtcbiAgY29uc3QgW2lzTW91bnRlZCwgc2V0SXNNb3VudGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2FjdGl2ZU5ldXJvbiwgc2V0QWN0aXZlTmV1cm9uXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbcHVsc2VzLCBzZXRQdWxzZXNdID0gdXNlU3RhdGU8UHVsc2VbXT4oW10pO1xuXG4gIGNvbnN0IGlzQ29hcnNlUG9pbnRlciA9IHVzZU1lbW8oKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm1hdGNoTWVkaWEgJiYgd2luZG93Lm1hdGNoTWVkaWEoJyhwb2ludGVyOiBjb2Fyc2UpJykubWF0Y2hlcywgW10pO1xuICBjb25zdCBwcmVmZXJzUmVkdWNlZE1vdGlvbiA9IHVzZU1lbW8oKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm1hdGNoTWVkaWEgJiYgd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpJykubWF0Y2hlcywgW10pO1xuXG4gIGNvbnN0IG5ldXJvbnMgPSB1c2VNZW1vKCgpID0+IGdlbmVyYXRlTmV1cm9ucyhpc0NvYXJzZVBvaW50ZXIgfHwgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPyAyMCA6IDMwKSwgW2lzQ29hcnNlUG9pbnRlciwgcHJlZmVyc1JlZHVjZWRNb3Rpb25dKTtcbiAgY29uc3QgYW5pbWF0aW9uUmVmID0gdXNlUmVmPG51bWJlcj4oKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldElzTW91bnRlZCh0cnVlKTtcbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc01vdW50ZWQgfHwgcHJlZmVyc1JlZHVjZWRNb3Rpb24pIHJldHVybjtcblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlTW92ZSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB4ID0gKChlLmNsaWVudFggLSByZWN0LmxlZnQpIC8gcmVjdC53aWR0aCkgKiAxMDA7XG4gICAgICAgIGNvbnN0IHkgPSAoKGUuY2xpZW50WSAtIHJlY3QudG9wKSAvIHJlY3QuaGVpZ2h0KSAqIDEwMDtcbiAgICAgICAgc2V0TW91c2VQb3MoeyB4LCB5IH0pO1xuXG4gICAgICAgIGlmICghaXNDb2Fyc2VQb2ludGVyKSB7XG4gICAgICAgICAgLy8gRmluZCBuZWFyZXN0IG5ldXJvbiB0byBtb3VzZVxuICAgICAgICAgIGxldCBuZWFyZXN0TmV1cm9uOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICBsZXQgbWluRGlzdGFuY2UgPSAxNjsgLy8gaW5jcmVhc2UgY2FwdHVyZSByYWRpdXMgc2xpZ2h0bHlcblxuICAgICAgICAgIG5ldXJvbnMuZm9yRWFjaCgobmV1cm9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChcbiAgICAgICAgICAgICAgTWF0aC5wb3coeCAtIG5ldXJvbi54LCAyKSArIE1hdGgucG93KHkgLSBuZXVyb24ueSwgMilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICBuZWFyZXN0TmV1cm9uID0gbmV1cm9uLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc2V0QWN0aXZlTmV1cm9uKG5lYXJlc3ROZXVyb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9ICgpID0+IHNldEFjdGl2ZU5ldXJvbihudWxsKTtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgb25Nb3VzZUxlYXZlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgb25Nb3VzZUxlYXZlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbaXNNb3VudGVkLCBuZXVyb25zLCBpc0NvYXJzZVBvaW50ZXIsIHByZWZlcnNSZWR1Y2VkTW90aW9uXSk7XG5cbiAgLy8gQW5pbWF0ZSBwdWxzZXMgYWxvbmcgY29ubmVjdGlvbnNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzTW91bnRlZCB8fCBwcmVmZXJzUmVkdWNlZE1vdGlvbikgcmV0dXJuO1xuXG4gICAgbGV0IGxhc3RTcGF3biA9IDA7XG4gICAgY29uc3Qgc3Bhd25JbnRlcnZhbCA9IGlzQ29hcnNlUG9pbnRlciA/IDE2MDAgOiAxMjAwOyAvLyBzbG93ZXIgZmlyaW5nIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBtYXhQdWxzZXMgPSBpc0NvYXJzZVBvaW50ZXIgPyA0IDogNjsgLy8gZmV3ZXIgY29uY3VycmVudCBwdWxzZXNcblxuICAgIGNvbnN0IGFuaW1hdGVQdWxzZXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICAvLyBBZGQgbmV3IHB1bHNlcyB3aXRoIHRocm90dGxpbmdcbiAgICAgIGlmIChub3cgLSBsYXN0U3Bhd24gPiBzcGF3bkludGVydmFsICYmIHB1bHNlcy5sZW5ndGggPCBtYXhQdWxzZXMpIHtcbiAgICAgICAgbGFzdFNwYXduID0gbm93O1xuICAgICAgICBjb25zdCByYW5kb21OZXVyb24gPSBuZXVyb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5ldXJvbnMubGVuZ3RoKV07XG4gICAgICAgIGlmIChyYW5kb21OZXVyb24uY29ubmVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldElkID0gcmFuZG9tTmV1cm9uLmNvbm5lY3Rpb25zW1xuICAgICAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmFuZG9tTmV1cm9uLmNvbm5lY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgc2V0UHVsc2VzKHByZXYgPT4gWy4uLnByZXYsIHtcbiAgICAgICAgICAgIGlkOiBgJHtyYW5kb21OZXVyb24uaWR9LSR7dGFyZ2V0SWR9LSR7bm93fWAsXG4gICAgICAgICAgICBmcm9tOiByYW5kb21OZXVyb24uaWQsXG4gICAgICAgICAgICB0bzogdGFyZ2V0SWQsXG4gICAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogbm93LFxuICAgICAgICAgIH1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgcHVsc2VzXG4gICAgICBzZXRQdWxzZXMocHJldiA9PiBwcmV2XG4gICAgICAgIC5tYXAocHVsc2UgPT4gKHtcbiAgICAgICAgICAuLi5wdWxzZSxcbiAgICAgICAgICBwcm9ncmVzczogTWF0aC5taW4oKG5vdyAtIHB1bHNlLnN0YXJ0VGltZSkgLyAxMTAwLCAxKSxcbiAgICAgICAgfSkpXG4gICAgICAgIC5maWx0ZXIocHVsc2UgPT4gcHVsc2UucHJvZ3Jlc3MgPCAxKVxuICAgICAgKTtcblxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZVB1bHNlcyk7XG4gICAgfTtcblxuICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGVQdWxzZXMpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25SZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lzTW91bnRlZCwgbmV1cm9ucywgcHVsc2VzLmxlbmd0aCwgaXNDb2Fyc2VQb2ludGVyLCBwcmVmZXJzUmVkdWNlZE1vdGlvbl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gUGF1c2UgYW5pbWF0aW9uIGFuZCBlZmZlY3RzIHdoZW4gdGFiIGlzIGhpZGRlblxuICAgIGNvbnN0IGhhbmRsZVZpc2liaWxpdHkgPSAoKSA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuICYmIGFuaW1hdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblJlZi5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIXByZWZlcnNSZWR1Y2VkTW90aW9uKSB7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHt9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5KTtcbiAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHkpO1xuICB9LCBbcHJlZmVyc1JlZHVjZWRNb3Rpb25dKTtcblxuICBjb25zdCBnZXRDb25uZWN0aW9uT3BhY2l0eSA9IChmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpID0+IHtcbiAgICBpZiAoYWN0aXZlTmV1cm9uID09PSBmcm9tIHx8IGFjdGl2ZU5ldXJvbiA9PT0gdG8pIHJldHVybiAwLjc1O1xuICAgIHJldHVybiAwLjA4O1xuICB9O1xuXG4gIGNvbnN0IGdldE5ldXJvblNjYWxlID0gKG5ldXJvbklkOiBudW1iZXIpID0+IHtcbiAgICBpZiAoYWN0aXZlTmV1cm9uID09PSBuZXVyb25JZCkgcmV0dXJuIDEuMzU7XG4gICAgaWYgKGFjdGl2ZU5ldXJvbiAhPT0gbnVsbCAmJiBuZXVyb25zW2FjdGl2ZU5ldXJvbl0/LmNvbm5lY3Rpb25zLmluY2x1ZGVzKG5ldXJvbklkKSkgcmV0dXJuIDEuMTU7XG4gICAgcmV0dXJuIDE7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IHJlZj17Y29udGFpbmVyUmVmfSBjbGFzc05hbWU9XCJhYnNvbHV0ZSBpbnNldC0wIG92ZXJmbG93LWhpZGRlblwiPlxuICAgICAgey8qIEJhc2UgZ3JhZGllbnQgb3ZlcmxheSAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBiZy1ncmFkaWVudC10by10ciBmcm9tLWluZGlnby05NTAvMTAgdmlhLXRyYW5zcGFyZW50IHRvLXB1cnBsZS05NTAvMTBcIj48L2Rpdj5cblxuICAgICAgey8qIFNvZnQgZ2xvYmFsIGJsdXIgdG8gcmVkdWNlIHNoYXJwbmVzcyAtIG9ubHkgcmVuZGVyIG9uIGNsaWVudCAqL31cbiAgICAgIHtpc01vdW50ZWQgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTBcIiBzdHlsZT17eyBmaWx0ZXI6ICdibHVyKDAuNXB4KScgfX0gLz5cbiAgICAgICl9XG5cbiAgICAgIHsvKiBOZXVyYWwgbmV0d29yayB2aXN1YWxpemF0aW9uICovfVxuICAgICAge2lzTW91bnRlZCAmJiAhcHJlZmVyc1JlZHVjZWRNb3Rpb24gJiYgKFxuICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgdy1mdWxsIGgtZnVsbFwiPlxuICAgICAgICAgIHsvKiBDb25uZWN0aW9ucyAqL31cbiAgICAgICAgICB7bmV1cm9ucy5tYXAoKG5ldXJvbikgPT5cbiAgICAgICAgICAgIG5ldXJvbi5jb25uZWN0aW9ucy5tYXAoKHRhcmdldElkKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5ldXJvbnNbdGFyZ2V0SWRdO1xuICAgICAgICAgICAgICBpZiAoIXRhcmdldCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgICAgY29uc3QgaXNBY3RpdmUgPSBhY3RpdmVOZXVyb24gPT09IG5ldXJvbi5pZCB8fCBhY3RpdmVOZXVyb24gPT09IHRhcmdldElkO1xuXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPG1vdGlvbi5saW5lXG4gICAgICAgICAgICAgICAgICBrZXk9e2Ake25ldXJvbi5pZH0tJHt0YXJnZXRJZH1gfVxuICAgICAgICAgICAgICAgICAgeDE9e2Ake25ldXJvbi54fSVgfVxuICAgICAgICAgICAgICAgICAgeTE9e2Ake25ldXJvbi55fSVgfVxuICAgICAgICAgICAgICAgICAgeDI9e2Ake3RhcmdldC54fSVgfVxuICAgICAgICAgICAgICAgICAgeTI9e2Ake3RhcmdldC55fSVgfVxuICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwicmdiYSg5OSwgMTAyLCAyNDEsIDAuMilcIlxuICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9ezAuMzV9XG4gICAgICAgICAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAgfX1cbiAgICAgICAgICAgICAgICAgIGFuaW1hdGU9e3tcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogZ2V0Q29ubmVjdGlvbk9wYWNpdHkobmV1cm9uLmlkLCB0YXJnZXRJZCksXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogaXNBY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgICA/IFwicmdiYSgxMzksIDkyLCAyNDYsIDAuNylcIlxuICAgICAgICAgICAgICAgICAgICAgIDogXCJyZ2JhKDk5LCAxMDIsIDI0MSwgMC4yKVwiLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogaXNBY3RpdmUgPyAwLjcgOiAwLjM1LFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuMiB9fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICl9XG5cbiAgICAgICAgICB7LyogUHVsc2VzICovfVxuICAgICAgICAgIHtwdWxzZXMubWFwKChwdWxzZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IG5ldXJvbnNbcHVsc2UuZnJvbV07XG4gICAgICAgICAgICBjb25zdCB0byA9IG5ldXJvbnNbcHVsc2UudG9dO1xuICAgICAgICAgICAgaWYgKCFmcm9tIHx8ICF0bykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIGNvbnN0IHggPSBmcm9tLnggKyAodG8ueCAtIGZyb20ueCkgKiBwdWxzZS5wcm9ncmVzcztcbiAgICAgICAgICAgIGNvbnN0IHkgPSBmcm9tLnkgKyAodG8ueSAtIGZyb20ueSkgKiBwdWxzZS5wcm9ncmVzcztcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgICAgIGtleT17cHVsc2UuaWR9XG4gICAgICAgICAgICAgICAgY3g9e2Ake3h9JWB9XG4gICAgICAgICAgICAgICAgY3k9e2Ake3l9JWB9XG4gICAgICAgICAgICAgICAgcj1cIjEuOFwiXG4gICAgICAgICAgICAgICAgZmlsbD1cInJnYmEoMTY4LCA4NSwgMjQ3LCAwLjc1KVwiXG4gICAgICAgICAgICAgICAgb3BhY2l0eT17MSAtIHB1bHNlLnByb2dyZXNzICogMC41fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGFuaW1hdGVcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU9XCJyXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlcz1cIjEuODszOzEuOFwiXG4gICAgICAgICAgICAgICAgICBkdXI9XCIwLjZzXCJcbiAgICAgICAgICAgICAgICAgIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9jaXJjbGU+XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pfVxuXG4gICAgICAgICAgey8qIE5ldXJvbnMgKi99XG4gICAgICAgICAge25ldXJvbnMubWFwKChuZXVyb24pID0+IChcbiAgICAgICAgICAgIDxtb3Rpb24uZyBrZXk9e25ldXJvbi5pZH0+XG4gICAgICAgICAgICAgIHsvKiBPdXRlciBnbG93ICovfVxuICAgICAgICAgICAgICA8bW90aW9uLmNpcmNsZVxuICAgICAgICAgICAgICAgIGN4PXtgJHtuZXVyb24ueH0lYH1cbiAgICAgICAgICAgICAgICBjeT17YCR7bmV1cm9uLnl9JWB9XG4gICAgICAgICAgICAgICAgcj1cIjdcIlxuICAgICAgICAgICAgICAgIGZpbGw9XCJyZ2JhKDEzOSwgOTIsIDI0NiwgMC4wOClcIlxuICAgICAgICAgICAgICAgIGluaXRpYWw9e3sgc2NhbGU6IDAgfX1cbiAgICAgICAgICAgICAgICBhbmltYXRlPXt7XG4gICAgICAgICAgICAgICAgICBzY2FsZTogZ2V0TmV1cm9uU2NhbGUobmV1cm9uLmlkKSxcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGFjdGl2ZU5ldXJvbiA9PT0gbmV1cm9uLmlkID8gMC4yNSA6IDAuMDhcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuMyB9fVxuICAgICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICAgIHsvKiBJbm5lciBuZXVyb24gKi99XG4gICAgICAgICAgICAgIDxtb3Rpb24uY2lyY2xlXG4gICAgICAgICAgICAgICAgY3g9e2Ake25ldXJvbi54fSVgfVxuICAgICAgICAgICAgICAgIGN5PXtgJHtuZXVyb24ueX0lYH1cbiAgICAgICAgICAgICAgICByPVwiMi42XCJcbiAgICAgICAgICAgICAgICBmaWxsPVwicmdiYSg5OSwgMTAyLCAyNDEsIDAuNDUpXCJcbiAgICAgICAgICAgICAgICBpbml0aWFsPXt7IHNjYWxlOiAwIH19XG4gICAgICAgICAgICAgICAgYW5pbWF0ZT17e1xuICAgICAgICAgICAgICAgICAgc2NhbGU6IGdldE5ldXJvblNjYWxlKG5ldXJvbi5pZCksXG4gICAgICAgICAgICAgICAgICBmaWxsOiBhY3RpdmVOZXVyb24gPT09IG5ldXJvbi5pZFxuICAgICAgICAgICAgICAgICAgICA/IFwicmdiYSgxNjgsIDg1LCAyNDcsIDAuNzUpXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcInJnYmEoOTksIDEwMiwgMjQxLCAwLjQ1KVwiXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uPXt7XG4gICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMC4zLFxuICAgICAgICAgICAgICAgICAgZGVsYXk6IG5ldXJvbi5wdWxzZURlbGF5LFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8YW5pbWF0ZVxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZT1cIm9wYWNpdHlcIlxuICAgICAgICAgICAgICAgICAgdmFsdWVzPVwiMC41OzAuNzU7MC41XCJcbiAgICAgICAgICAgICAgICAgIGR1cj17YCR7MyArIG5ldXJvbi5wdWxzZURlbGF5fXNgfVxuICAgICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L21vdGlvbi5jaXJjbGU+XG5cbiAgICAgICAgICAgICAgey8qIENvcmUgKi99XG4gICAgICAgICAgICAgIDxjaXJjbGVcbiAgICAgICAgICAgICAgICBjeD17YCR7bmV1cm9uLnh9JWB9XG4gICAgICAgICAgICAgICAgY3k9e2Ake25ldXJvbi55fSVgfVxuICAgICAgICAgICAgICAgIHI9XCIwLjlcIlxuICAgICAgICAgICAgICAgIGZpbGw9XCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOClcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9tb3Rpb24uZz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9zdmc+XG4gICAgICApfVxuXG4gICAgICB7LyogTW91c2UgZ2xvdyBlZmZlY3QgKi99XG4gICAgICB7aXNNb3VudGVkICYmICFwcmVmZXJzUmVkdWNlZE1vdGlvbiAmJiAoXG4gICAgICAgIDxtb3Rpb24uZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgdy02NCBoLTY0IHJvdW5kZWQtZnVsbCBwb2ludGVyLWV2ZW50cy1ub25lXCJcbiAgICAgICAgICBhbmltYXRlPXt7XG4gICAgICAgICAgICB4OiBtb3VzZVBvcy54ICogKGNvbnRhaW5lclJlZi5jdXJyZW50Py5vZmZzZXRXaWR0aCB8fCAwKSAvIDEwMCAtIDEyOCxcbiAgICAgICAgICAgIHk6IG1vdXNlUG9zLnkgKiAoY29udGFpbmVyUmVmLmN1cnJlbnQ/Lm9mZnNldEhlaWdodCB8fCAwKSAvIDEwMCAtIDEyOCxcbiAgICAgICAgICB9fVxuICAgICAgICAgIHRyYW5zaXRpb249e3tcbiAgICAgICAgICAgIHR5cGU6IFwic3ByaW5nXCIsXG4gICAgICAgICAgICBkYW1waW5nOiAzMCxcbiAgICAgICAgICAgIHN0aWZmbmVzczogMjAwLFxuICAgICAgICAgIH19XG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwicmFkaWFsLWdyYWRpZW50KGNpcmNsZSwgcmdiYSgxMzksIDkyLCAyNDYsIDAuMDgpIDAlLCB0cmFuc3BhcmVudCA3MCUpXCIsXG4gICAgICAgICAgICBmaWx0ZXI6IFwiYmx1cig0MHB4KVwiLFxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICApfVxuXG4gICAgICB7LyogRWRnZSBmYWRlcyBmb3IgYmxlbmRpbmcgKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGJvdHRvbS0wIGxlZnQtMCByaWdodC0wIGgtMzIgYmctZ3JhZGllbnQtdG8tdCBmcm9tLXNsYXRlLTk1MCB0by10cmFuc3BhcmVudFwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgcmlnaHQtMCBoLTI0IGJnLWdyYWRpZW50LXRvLWIgZnJvbS1zbGF0ZS05NTAgdG8tdHJhbnNwYXJlbnRcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VNZW1vIiwibW90aW9uIiwiZ2VuZXJhdGVOZXVyb25zIiwiY291bnRPdmVycmlkZSIsIm5ldXJvbnMiLCJncmlkU2l6ZSIsInNwcmVhZCIsInRvdGFsIiwiaSIsImdyaWRYIiwiTWF0aCIsImZsb29yIiwiZ3JpZFkiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInB1c2giLCJpZCIsIngiLCJ5IiwiY29ubmVjdGlvbnMiLCJwdWxzZURlbGF5IiwiZm9yRWFjaCIsIm5ldXJvbiIsIm90aGVyIiwiaiIsImRpc3RhbmNlIiwic3FydCIsInBvdyIsImxlbmd0aCIsIk5ldXJhbE5ldHdvcmsiLCJjb250YWluZXJSZWYiLCJtb3VzZVBvcyIsInNldE1vdXNlUG9zIiwiaXNNb3VudGVkIiwic2V0SXNNb3VudGVkIiwiYWN0aXZlTmV1cm9uIiwic2V0QWN0aXZlTmV1cm9uIiwicHVsc2VzIiwic2V0UHVsc2VzIiwiaXNDb2Fyc2VQb2ludGVyIiwid2luZG93IiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJwcmVmZXJzUmVkdWNlZE1vdGlvbiIsImFuaW1hdGlvblJlZiIsImhhbmRsZU1vdXNlTW92ZSIsImUiLCJjdXJyZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJsZWZ0Iiwid2lkdGgiLCJjbGllbnRZIiwidG9wIiwiaGVpZ2h0IiwibmVhcmVzdE5ldXJvbiIsIm1pbkRpc3RhbmNlIiwib25Nb3VzZUxlYXZlIiwiY29udGFpbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsYXN0U3Bhd24iLCJzcGF3bkludGVydmFsIiwibWF4UHVsc2VzIiwiYW5pbWF0ZVB1bHNlcyIsIm5vdyIsIkRhdGUiLCJyYW5kb21OZXVyb24iLCJyYW5kb20iLCJ0YXJnZXRJZCIsInByZXYiLCJmcm9tIiwidG8iLCJwcm9ncmVzcyIsInN0YXJ0VGltZSIsIm1hcCIsInB1bHNlIiwibWluIiwiZmlsdGVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVWaXNpYmlsaXR5IiwiZG9jdW1lbnQiLCJoaWRkZW4iLCJnZXRDb25uZWN0aW9uT3BhY2l0eSIsImdldE5ldXJvblNjYWxlIiwibmV1cm9uSWQiLCJpbmNsdWRlcyIsImRpdiIsInJlZiIsImNsYXNzTmFtZSIsInN0eWxlIiwic3ZnIiwidGFyZ2V0IiwiaXNBY3RpdmUiLCJsaW5lIiwieDEiLCJ5MSIsIngyIiwieTIiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsImluaXRpYWwiLCJvcGFjaXR5IiwiYW5pbWF0ZSIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsImNpcmNsZSIsImN4IiwiY3kiLCJyIiwiZmlsbCIsImF0dHJpYnV0ZU5hbWUiLCJ2YWx1ZXMiLCJkdXIiLCJyZXBlYXRDb3VudCIsImciLCJzY2FsZSIsImRlbGF5Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJ0eXBlIiwiZGFtcGluZyIsInN0aWZmbmVzcyIsImJhY2tncm91bmQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/NeuralNetwork.tsx\n"));

/***/ })

});