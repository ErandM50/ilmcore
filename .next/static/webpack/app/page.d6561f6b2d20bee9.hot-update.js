"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/NeuralNetwork.tsx":
/*!**************************************!*\
  !*** ./components/NeuralNetwork.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ NeuralNetwork)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n// Generate fixed neuron positions using deterministic algorithm\nconst generateNeurons = (countOverride)=>{\n    const neurons = [];\n    const gridSize = 8;\n    const spread = 12;\n    const total = typeof countOverride === 'number' ? countOverride : 25;\n    for(let i = 0; i < total; i++){\n        const gridX = i % gridSize * spread + Math.floor(i / gridSize) % 2 * (spread / 2);\n        const gridY = Math.floor(i / gridSize) * spread;\n        // Add some deterministic variation\n        const offsetX = i * 13 % 7 - 3;\n        const offsetY = i * 17 % 5 - 2;\n        neurons.push({\n            id: i,\n            x: 15 + gridX + offsetX,\n            y: 20 + gridY + offsetY,\n            connections: [],\n            pulseDelay: i * 0.3 % 4\n        });\n    }\n    // Create connections between nearby neurons\n    neurons.forEach((neuron, i)=>{\n        neurons.forEach((other, j)=>{\n            if (i !== j) {\n                const distance = Math.sqrt(Math.pow(neuron.x - other.x, 2) + Math.pow(neuron.y - other.y, 2));\n                if (distance < 20 && neuron.connections.length < 2) {\n                    neuron.connections.push(j);\n                }\n            }\n        });\n    });\n    return neurons;\n};\nfunction NeuralNetwork() {\n    var _containerRef_current, _containerRef_current1;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [mousePos, setMousePos] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 50,\n        y: 50\n    });\n    const [isMounted, setIsMounted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [activeNeuron, setActiveNeuron] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [pulses, setPulses] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const isCoarsePointer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"NeuralNetwork.useMemo[isCoarsePointer]\": ()=> true && window.matchMedia && window.matchMedia('(pointer: coarse)').matches\n    }[\"NeuralNetwork.useMemo[isCoarsePointer]\"], []);\n    const prefersReducedMotion = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"NeuralNetwork.useMemo[prefersReducedMotion]\": ()=> true && window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches\n    }[\"NeuralNetwork.useMemo[prefersReducedMotion]\"], []);\n    const neurons = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"NeuralNetwork.useMemo[neurons]\": ()=>generateNeurons(isCoarsePointer || prefersReducedMotion ? 16 : 25)\n    }[\"NeuralNetwork.useMemo[neurons]\"], [\n        isCoarsePointer,\n        prefersReducedMotion\n    ]);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NeuralNetwork.useEffect\": ()=>{\n            setIsMounted(true);\n        }\n    }[\"NeuralNetwork.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NeuralNetwork.useEffect\": ()=>{\n            if (!isMounted || prefersReducedMotion) return;\n            const handleMouseMove = {\n                \"NeuralNetwork.useEffect.handleMouseMove\": (e)=>{\n                    if (containerRef.current) {\n                        const rect = containerRef.current.getBoundingClientRect();\n                        const x = (e.clientX - rect.left) / rect.width * 100;\n                        const y = (e.clientY - rect.top) / rect.height * 100;\n                        setMousePos({\n                            x,\n                            y\n                        });\n                        if (!isCoarsePointer) {\n                            // Find nearest neuron to mouse\n                            let nearestNeuron = null;\n                            let minDistance = 12; // Slightly tighter threshold\n                            neurons.forEach({\n                                \"NeuralNetwork.useEffect.handleMouseMove\": (neuron)=>{\n                                    const distance = Math.sqrt(Math.pow(x - neuron.x, 2) + Math.pow(y - neuron.y, 2));\n                                    if (distance < minDistance) {\n                                        minDistance = distance;\n                                        nearestNeuron = neuron.id;\n                                    }\n                                }\n                            }[\"NeuralNetwork.useEffect.handleMouseMove\"]);\n                            setActiveNeuron(nearestNeuron);\n                        }\n                    }\n                }\n            }[\"NeuralNetwork.useEffect.handleMouseMove\"];\n            const onMouseLeave = {\n                \"NeuralNetwork.useEffect.onMouseLeave\": ()=>setActiveNeuron(null)\n            }[\"NeuralNetwork.useEffect.onMouseLeave\"];\n            const container = containerRef.current;\n            if (container) {\n                container.addEventListener(\"mousemove\", handleMouseMove);\n                container.addEventListener(\"mouseleave\", onMouseLeave);\n            }\n            return ({\n                \"NeuralNetwork.useEffect\": ()=>{\n                    if (container) {\n                        container.removeEventListener(\"mousemove\", handleMouseMove);\n                        container.removeEventListener(\"mouseleave\", onMouseLeave);\n                    }\n                }\n            })[\"NeuralNetwork.useEffect\"];\n        }\n    }[\"NeuralNetwork.useEffect\"], [\n        isMounted,\n        neurons,\n        isCoarsePointer,\n        prefersReducedMotion\n    ]);\n    // Animate pulses along connections\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NeuralNetwork.useEffect\": ()=>{\n            if (!isMounted || prefersReducedMotion) return;\n            let lastSpawn = 0;\n            const spawnInterval = isCoarsePointer ? 900 : 600; // throttle\n            const maxPulses = isCoarsePointer ? 6 : 10; // fewer on mobile\n            const animatePulses = {\n                \"NeuralNetwork.useEffect.animatePulses\": ()=>{\n                    const now = Date.now();\n                    // Add new pulses with throttling\n                    if (now - lastSpawn > spawnInterval && pulses.length < maxPulses) {\n                        lastSpawn = now;\n                        const randomNeuron = neurons[Math.floor(Math.random() * neurons.length)];\n                        if (randomNeuron.connections.length > 0) {\n                            const targetId = randomNeuron.connections[Math.floor(Math.random() * randomNeuron.connections.length)];\n                            setPulses({\n                                \"NeuralNetwork.useEffect.animatePulses\": (prev)=>[\n                                        ...prev,\n                                        {\n                                            id: \"\".concat(randomNeuron.id, \"-\").concat(targetId, \"-\").concat(now),\n                                            from: randomNeuron.id,\n                                            to: targetId,\n                                            progress: 0,\n                                            startTime: now\n                                        }\n                                    ]\n                            }[\"NeuralNetwork.useEffect.animatePulses\"]);\n                        }\n                    }\n                    // Update existing pulses\n                    setPulses({\n                        \"NeuralNetwork.useEffect.animatePulses\": (prev)=>prev.map({\n                                \"NeuralNetwork.useEffect.animatePulses\": (pulse)=>({\n                                        ...pulse,\n                                        progress: Math.min((now - pulse.startTime) / 1100, 1)\n                                    })\n                            }[\"NeuralNetwork.useEffect.animatePulses\"]).filter({\n                                \"NeuralNetwork.useEffect.animatePulses\": (pulse)=>pulse.progress < 1\n                            }[\"NeuralNetwork.useEffect.animatePulses\"])\n                    }[\"NeuralNetwork.useEffect.animatePulses\"]);\n                    animationRef.current = requestAnimationFrame(animatePulses);\n                }\n            }[\"NeuralNetwork.useEffect.animatePulses\"];\n            animationRef.current = requestAnimationFrame(animatePulses);\n            return ({\n                \"NeuralNetwork.useEffect\": ()=>{\n                    if (animationRef.current) {\n                        cancelAnimationFrame(animationRef.current);\n                    }\n                }\n            })[\"NeuralNetwork.useEffect\"];\n        }\n    }[\"NeuralNetwork.useEffect\"], [\n        isMounted,\n        neurons,\n        pulses.length,\n        isCoarsePointer,\n        prefersReducedMotion\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NeuralNetwork.useEffect\": ()=>{\n            // Pause animation and effects when tab is hidden\n            const handleVisibility = {\n                \"NeuralNetwork.useEffect.handleVisibility\": ()=>{\n                    if (document.hidden && animationRef.current) {\n                        cancelAnimationFrame(animationRef.current);\n                    } else if (!prefersReducedMotion) {\n                        animationRef.current = requestAnimationFrame({\n                            \"NeuralNetwork.useEffect.handleVisibility\": ()=>{}\n                        }[\"NeuralNetwork.useEffect.handleVisibility\"]);\n                    }\n                }\n            }[\"NeuralNetwork.useEffect.handleVisibility\"];\n            document.addEventListener('visibilitychange', handleVisibility);\n            return ({\n                \"NeuralNetwork.useEffect\": ()=>document.removeEventListener('visibilitychange', handleVisibility)\n            })[\"NeuralNetwork.useEffect\"];\n        }\n    }[\"NeuralNetwork.useEffect\"], [\n        prefersReducedMotion\n    ]);\n    const getConnectionOpacity = (from, to)=>{\n        if (activeNeuron === from || activeNeuron === to) return 0.5;\n        return 0.1;\n    };\n    const getNeuronScale = (neuronId)=>{\n        var _neurons_activeNeuron;\n        if (activeNeuron === neuronId) return 1.35;\n        if (activeNeuron !== null && ((_neurons_activeNeuron = neurons[activeNeuron]) === null || _neurons_activeNeuron === void 0 ? void 0 : _neurons_activeNeuron.connections.includes(neuronId))) return 1.15;\n        return 1;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"absolute inset-0 overflow-hidden\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 bg-gradient-to-tr from-indigo-950/10 via-transparent to-purple-950/10\"\n            }, void 0, false, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 205,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0\",\n                style: {\n                    filter: 'blur(0.5px)'\n                }\n            }, void 0, false, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 208,\n                columnNumber: 7\n            }, this),\n            isMounted && !prefersReducedMotion && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                className: \"absolute inset-0 w-full h-full\",\n                children: [\n                    neurons.map((neuron)=>neuron.connections.map((targetId)=>{\n                            const target = neurons[targetId];\n                            if (!target) return null;\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.line, {\n                                x1: \"\".concat(neuron.x, \"%\"),\n                                y1: \"\".concat(neuron.y, \"%\"),\n                                x2: \"\".concat(target.x, \"%\"),\n                                y2: \"\".concat(target.y, \"%\"),\n                                stroke: \"rgba(99, 102, 241, 0.25)\",\n                                strokeWidth: \"0.4\",\n                                initial: {\n                                    opacity: 0\n                                },\n                                animate: {\n                                    opacity: getConnectionOpacity(neuron.id, targetId),\n                                    stroke: activeNeuron === neuron.id || activeNeuron === targetId ? \"rgba(139, 92, 246, 0.4)\" : \"rgba(99, 102, 241, 0.25)\"\n                                },\n                                transition: {\n                                    duration: 0.3\n                                }\n                            }, \"\".concat(neuron.id, \"-\").concat(targetId), false, {\n                                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                lineNumber: 220,\n                                columnNumber: 17\n                            }, this);\n                        })),\n                    pulses.map((pulse)=>{\n                        const from = neurons[pulse.from];\n                        const to = neurons[pulse.to];\n                        if (!from || !to) return null;\n                        const x = from.x + (to.x - from.x) * pulse.progress;\n                        const y = from.y + (to.y - from.y) * pulse.progress;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                            cx: \"\".concat(x, \"%\"),\n                            cy: \"\".concat(y, \"%\"),\n                            r: \"1.8\",\n                            fill: \"rgba(168, 85, 247, 0.75)\",\n                            opacity: 1 - pulse.progress * 0.5,\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"animate\", {\n                                attributeName: \"r\",\n                                values: \"1.8;3;1.8\",\n                                dur: \"0.6s\",\n                                repeatCount: \"indefinite\"\n                            }, void 0, false, {\n                                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                lineNumber: 259,\n                                columnNumber: 17\n                            }, this)\n                        }, pulse.id, false, {\n                            fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                            lineNumber: 251,\n                            columnNumber: 15\n                        }, this);\n                    }),\n                    neurons.map((neuron)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.g, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.circle, {\n                                    cx: \"\".concat(neuron.x, \"%\"),\n                                    cy: \"\".concat(neuron.y, \"%\"),\n                                    r: \"7\",\n                                    fill: \"rgba(139, 92, 246, 0.08)\",\n                                    initial: {\n                                        scale: 0\n                                    },\n                                    animate: {\n                                        scale: getNeuronScale(neuron.id),\n                                        opacity: activeNeuron === neuron.id ? 0.25 : 0.08\n                                    },\n                                    transition: {\n                                        duration: 0.3\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                    lineNumber: 273,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.circle, {\n                                    cx: \"\".concat(neuron.x, \"%\"),\n                                    cy: \"\".concat(neuron.y, \"%\"),\n                                    r: \"2.6\",\n                                    fill: \"rgba(99, 102, 241, 0.45)\",\n                                    initial: {\n                                        scale: 0\n                                    },\n                                    animate: {\n                                        scale: getNeuronScale(neuron.id),\n                                        fill: activeNeuron === neuron.id ? \"rgba(168, 85, 247, 0.75)\" : \"rgba(99, 102, 241, 0.45)\"\n                                    },\n                                    transition: {\n                                        duration: 0.3,\n                                        delay: neuron.pulseDelay\n                                    },\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"animate\", {\n                                        attributeName: \"opacity\",\n                                        values: \"0.5;0.75;0.5\",\n                                        dur: \"\".concat(3 + neuron.pulseDelay, \"s\"),\n                                        repeatCount: \"indefinite\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                        lineNumber: 304,\n                                        columnNumber: 17\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                    lineNumber: 287,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                                    cx: \"\".concat(neuron.x, \"%\"),\n                                    cy: \"\".concat(neuron.y, \"%\"),\n                                    r: \"0.9\",\n                                    fill: \"rgba(255, 255, 255, 0.8)\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                                    lineNumber: 313,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, neuron.id, true, {\n                            fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                            lineNumber: 271,\n                            columnNumber: 13\n                        }, this))\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 212,\n                columnNumber: 9\n            }, this),\n            isMounted && !prefersReducedMotion && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_2__.motion.div, {\n                className: \"absolute w-64 h-64 rounded-full pointer-events-none\",\n                animate: {\n                    x: mousePos.x * (((_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.offsetWidth) || 0) / 100 - 128,\n                    y: mousePos.y * (((_containerRef_current1 = containerRef.current) === null || _containerRef_current1 === void 0 ? void 0 : _containerRef_current1.offsetHeight) || 0) / 100 - 128\n                },\n                transition: {\n                    type: \"spring\",\n                    damping: 30,\n                    stiffness: 200\n                },\n                style: {\n                    background: \"radial-gradient(circle, rgba(139, 92, 246, 0.08) 0%, transparent 70%)\",\n                    filter: \"blur(40px)\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 326,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute bottom-0 left-0 right-0 h-32 bg-gradient-to-t from-slate-950 to-transparent\"\n            }, void 0, false, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 345,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-0 left-0 right-0 h-24 bg-gradient-to-b from-slate-950 to-transparent\"\n            }, void 0, false, {\n                fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n                lineNumber: 346,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/erandmulla/ilmcore/components/NeuralNetwork.tsx\",\n        lineNumber: 203,\n        columnNumber: 5\n    }, this);\n}\n_s(NeuralNetwork, \"kJlSeec+ia4vUa9stf33bQsSW1A=\");\n_c = NeuralNetwork;\nvar _c;\n$RefreshReg$(_c, \"NeuralNetwork\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTmV1cmFsTmV0d29yay50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUU2RDtBQUN0QjtBQWtCdkMsZ0VBQWdFO0FBQ2hFLE1BQU1LLGtCQUFrQixDQUFDQztJQUN2QixNQUFNQyxVQUFvQixFQUFFO0lBQzVCLE1BQU1DLFdBQVc7SUFDakIsTUFBTUMsU0FBUztJQUVmLE1BQU1DLFFBQVEsT0FBT0osa0JBQWtCLFdBQVdBLGdCQUFnQjtJQUVsRSxJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSUQsT0FBT0MsSUFBSztRQUM5QixNQUFNQyxRQUFRLElBQUtKLFdBQVlDLFNBQVMsS0FBTUssS0FBSyxDQUFDSCxJQUFJSCxZQUFZLElBQU1DLENBQUFBLFNBQVM7UUFDbkYsTUFBTU0sUUFBUUYsS0FBS0MsS0FBSyxDQUFDSCxJQUFJSCxZQUFZQztRQUV6QyxtQ0FBbUM7UUFDbkMsTUFBTU8sVUFBVSxJQUFNLEtBQU0sSUFBSztRQUNqQyxNQUFNQyxVQUFVLElBQU0sS0FBTSxJQUFLO1FBRWpDVixRQUFRVyxJQUFJLENBQUM7WUFDWEMsSUFBSVI7WUFDSlMsR0FBRyxLQUFLUixRQUFRSTtZQUNoQkssR0FBRyxLQUFLTixRQUFRRTtZQUNoQkssYUFBYSxFQUFFO1lBQ2ZDLFlBQVksSUFBSyxNQUFPO1FBQzFCO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUNoQixRQUFRaUIsT0FBTyxDQUFDLENBQUNDLFFBQVFkO1FBQ3ZCSixRQUFRaUIsT0FBTyxDQUFDLENBQUNFLE9BQU9DO1lBQ3RCLElBQUloQixNQUFNZ0IsR0FBRztnQkFDWCxNQUFNQyxXQUFXZixLQUFLZ0IsSUFBSSxDQUN4QmhCLEtBQUtpQixHQUFHLENBQUNMLE9BQU9MLENBQUMsR0FBR00sTUFBTU4sQ0FBQyxFQUFFLEtBQUtQLEtBQUtpQixHQUFHLENBQUNMLE9BQU9KLENBQUMsR0FBR0ssTUFBTUwsQ0FBQyxFQUFFO2dCQUVqRSxJQUFJTyxXQUFXLE1B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QUFRO2dCQUNWOzs7Ozs7MEJBS0osOERBQUNVO2dCQUFJRSxXQUFVOzs7Ozs7MEJBQ2YsOERBQUNGO2dCQUFJRSxXQUFVOzs7Ozs7Ozs7Ozs7QUFHckI7R0E3UndCOUQ7S0FBQUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lcmFuZG11bGxhL2lsbWNvcmUvY29tcG9uZW50cy9OZXVyYWxOZXR3b3JrLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBtb3Rpb24gfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiO1xuXG5pbnRlcmZhY2UgTmV1cm9uIHtcbiAgaWQ6IG51bWJlcjtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIGNvbm5lY3Rpb25zOiBudW1iZXJbXTtcbiAgcHVsc2VEZWxheTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgUHVsc2Uge1xuICBpZDogc3RyaW5nO1xuICBmcm9tOiBudW1iZXI7XG4gIHRvOiBudW1iZXI7XG4gIHByb2dyZXNzOiBudW1iZXI7XG4gIHN0YXJ0VGltZTogbnVtYmVyO1xufVxuXG4vLyBHZW5lcmF0ZSBmaXhlZCBuZXVyb24gcG9zaXRpb25zIHVzaW5nIGRldGVybWluaXN0aWMgYWxnb3JpdGhtXG5jb25zdCBnZW5lcmF0ZU5ldXJvbnMgPSAoY291bnRPdmVycmlkZT86IG51bWJlcik6IE5ldXJvbltdID0+IHtcbiAgY29uc3QgbmV1cm9uczogTmV1cm9uW10gPSBbXTtcbiAgY29uc3QgZ3JpZFNpemUgPSA4O1xuICBjb25zdCBzcHJlYWQgPSAxMjtcblxuICBjb25zdCB0b3RhbCA9IHR5cGVvZiBjb3VudE92ZXJyaWRlID09PSAnbnVtYmVyJyA/IGNvdW50T3ZlcnJpZGUgOiAyNTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICBjb25zdCBncmlkWCA9IChpICUgZ3JpZFNpemUpICogc3ByZWFkICsgKE1hdGguZmxvb3IoaSAvIGdyaWRTaXplKSAlIDIpICogKHNwcmVhZCAvIDIpO1xuICAgIGNvbnN0IGdyaWRZID0gTWF0aC5mbG9vcihpIC8gZ3JpZFNpemUpICogc3ByZWFkO1xuXG4gICAgLy8gQWRkIHNvbWUgZGV0ZXJtaW5pc3RpYyB2YXJpYXRpb25cbiAgICBjb25zdCBvZmZzZXRYID0gKChpICogMTMpICUgNykgLSAzO1xuICAgIGNvbnN0IG9mZnNldFkgPSAoKGkgKiAxNykgJSA1KSAtIDI7XG5cbiAgICBuZXVyb25zLnB1c2goe1xuICAgICAgaWQ6IGksXG4gICAgICB4OiAxNSArIGdyaWRYICsgb2Zmc2V0WCxcbiAgICAgIHk6IDIwICsgZ3JpZFkgKyBvZmZzZXRZLFxuICAgICAgY29ubmVjdGlvbnM6IFtdLFxuICAgICAgcHVsc2VEZWxheTogKGkgKiAwLjMpICUgNCxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBjb25uZWN0aW9ucyBiZXR3ZWVuIG5lYXJieSBuZXVyb25zXG4gIG5ldXJvbnMuZm9yRWFjaCgobmV1cm9uLCBpKSA9PiB7XG4gICAgbmV1cm9ucy5mb3JFYWNoKChvdGhlciwgaikgPT4ge1xuICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgTWF0aC5wb3cobmV1cm9uLnggLSBvdGhlci54LCAyKSArIE1hdGgucG93KG5ldXJvbi55IC0gb3RoZXIueSwgMilcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgMjAgJiYgbmV1cm9uLmNvbm5lY3Rpb25zLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICBuZXVyb24uY29ubmVjdGlvbnMucHVzaChqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gbmV1cm9ucztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE5ldXJhbE5ldHdvcmsoKSB7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IFttb3VzZVBvcywgc2V0TW91c2VQb3NdID0gdXNlU3RhdGUoeyB4OiA1MCwgeTogNTAgfSk7XG4gIGNvbnN0IFtpc01vdW50ZWQsIHNldElzTW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFthY3RpdmVOZXVyb24sIHNldEFjdGl2ZU5ldXJvbl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3B1bHNlcywgc2V0UHVsc2VzXSA9IHVzZVN0YXRlPFB1bHNlW10+KFtdKTtcblxuICBjb25zdCBpc0NvYXJzZVBvaW50ZXIgPSB1c2VNZW1vKCgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tYXRjaE1lZGlhICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcocG9pbnRlcjogY29hcnNlKScpLm1hdGNoZXMsIFtdKTtcbiAgY29uc3QgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPSB1c2VNZW1vKCgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tYXRjaE1lZGlhICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKScpLm1hdGNoZXMsIFtdKTtcblxuICBjb25zdCBuZXVyb25zID0gdXNlTWVtbygoKSA9PiBnZW5lcmF0ZU5ldXJvbnMoaXNDb2Fyc2VQb2ludGVyIHx8IHByZWZlcnNSZWR1Y2VkTW90aW9uID8gMTYgOiAyNSksIFtpc0NvYXJzZVBvaW50ZXIsIHByZWZlcnNSZWR1Y2VkTW90aW9uXSk7XG4gIGNvbnN0IGFuaW1hdGlvblJlZiA9IHVzZVJlZjxudW1iZXI+KCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRJc01vdW50ZWQodHJ1ZSk7XG4gIH0sIFtdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNNb3VudGVkIHx8IHByZWZlcnNSZWR1Y2VkTW90aW9uKSByZXR1cm47XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgeCA9ICgoZS5jbGllbnRYIC0gcmVjdC5sZWZ0KSAvIHJlY3Qud2lkdGgpICogMTAwO1xuICAgICAgICBjb25zdCB5ID0gKChlLmNsaWVudFkgLSByZWN0LnRvcCkgLyByZWN0LmhlaWdodCkgKiAxMDA7XG4gICAgICAgIHNldE1vdXNlUG9zKHsgeCwgeSB9KTtcblxuICAgICAgICBpZiAoIWlzQ29hcnNlUG9pbnRlcikge1xuICAgICAgICAgIC8vIEZpbmQgbmVhcmVzdCBuZXVyb24gdG8gbW91c2VcbiAgICAgICAgICBsZXQgbmVhcmVzdE5ldXJvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gMTI7IC8vIFNsaWdodGx5IHRpZ2h0ZXIgdGhyZXNob2xkXG5cbiAgICAgICAgICBuZXVyb25zLmZvckVhY2goKG5ldXJvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgIE1hdGgucG93KHggLSBuZXVyb24ueCwgMikgKyBNYXRoLnBvdyh5IC0gbmV1cm9uLnksIDIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgbmVhcmVzdE5ldXJvbiA9IG5ldXJvbi5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNldEFjdGl2ZU5ldXJvbihuZWFyZXN0TmV1cm9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvbk1vdXNlTGVhdmUgPSAoKSA9PiBzZXRBY3RpdmVOZXVyb24obnVsbCk7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIG9uTW91c2VMZWF2ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIG9uTW91c2VMZWF2ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lzTW91bnRlZCwgbmV1cm9ucywgaXNDb2Fyc2VQb2ludGVyLCBwcmVmZXJzUmVkdWNlZE1vdGlvbl0pO1xuXG4gIC8vIEFuaW1hdGUgcHVsc2VzIGFsb25nIGNvbm5lY3Rpb25zXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc01vdW50ZWQgfHwgcHJlZmVyc1JlZHVjZWRNb3Rpb24pIHJldHVybjtcblxuICAgIGxldCBsYXN0U3Bhd24gPSAwO1xuICAgIGNvbnN0IHNwYXduSW50ZXJ2YWwgPSBpc0NvYXJzZVBvaW50ZXIgPyA5MDAgOiA2MDA7IC8vIHRocm90dGxlXG4gICAgY29uc3QgbWF4UHVsc2VzID0gaXNDb2Fyc2VQb2ludGVyID8gNiA6IDEwOyAvLyBmZXdlciBvbiBtb2JpbGVcblxuICAgIGNvbnN0IGFuaW1hdGVQdWxzZXMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICAvLyBBZGQgbmV3IHB1bHNlcyB3aXRoIHRocm90dGxpbmdcbiAgICAgIGlmIChub3cgLSBsYXN0U3Bhd24gPiBzcGF3bkludGVydmFsICYmIHB1bHNlcy5sZW5ndGggPCBtYXhQdWxzZXMpIHtcbiAgICAgICAgbGFzdFNwYXduID0gbm93O1xuICAgICAgICBjb25zdCByYW5kb21OZXVyb24gPSBuZXVyb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5ldXJvbnMubGVuZ3RoKV07XG4gICAgICAgIGlmIChyYW5kb21OZXVyb24uY29ubmVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldElkID0gcmFuZG9tTmV1cm9uLmNvbm5lY3Rpb25zW1xuICAgICAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmFuZG9tTmV1cm9uLmNvbm5lY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgc2V0UHVsc2VzKHByZXYgPT4gWy4uLnByZXYsIHtcbiAgICAgICAgICAgIGlkOiBgJHtyYW5kb21OZXVyb24uaWR9LSR7dGFyZ2V0SWR9LSR7bm93fWAsXG4gICAgICAgICAgICBmcm9tOiByYW5kb21OZXVyb24uaWQsXG4gICAgICAgICAgICB0bzogdGFyZ2V0SWQsXG4gICAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogbm93LFxuICAgICAgICAgIH1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgcHVsc2VzXG4gICAgICBzZXRQdWxzZXMocHJldiA9PiBwcmV2XG4gICAgICAgIC5tYXAocHVsc2UgPT4gKHtcbiAgICAgICAgICAuLi5wdWxzZSxcbiAgICAgICAgICBwcm9ncmVzczogTWF0aC5taW4oKG5vdyAtIHB1bHNlLnN0YXJ0VGltZSkgLyAxMTAwLCAxKSxcbiAgICAgICAgfSkpXG4gICAgICAgIC5maWx0ZXIocHVsc2UgPT4gcHVsc2UucHJvZ3Jlc3MgPCAxKVxuICAgICAgKTtcblxuICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZVB1bHNlcyk7XG4gICAgfTtcblxuICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGVQdWxzZXMpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChhbmltYXRpb25SZWYuY3VycmVudCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25SZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lzTW91bnRlZCwgbmV1cm9ucywgcHVsc2VzLmxlbmd0aCwgaXNDb2Fyc2VQb2ludGVyLCBwcmVmZXJzUmVkdWNlZE1vdGlvbl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gUGF1c2UgYW5pbWF0aW9uIGFuZCBlZmZlY3RzIHdoZW4gdGFiIGlzIGhpZGRlblxuICAgIGNvbnN0IGhhbmRsZVZpc2liaWxpdHkgPSAoKSA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuICYmIGFuaW1hdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblJlZi5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIXByZWZlcnNSZWR1Y2VkTW90aW9uKSB7XG4gICAgICAgIGFuaW1hdGlvblJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHt9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5KTtcbiAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHkpO1xuICB9LCBbcHJlZmVyc1JlZHVjZWRNb3Rpb25dKTtcblxuICBjb25zdCBnZXRDb25uZWN0aW9uT3BhY2l0eSA9IChmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpID0+IHtcbiAgICBpZiAoYWN0aXZlTmV1cm9uID09PSBmcm9tIHx8IGFjdGl2ZU5ldXJvbiA9PT0gdG8pIHJldHVybiAwLjU7XG4gICAgcmV0dXJuIDAuMTtcbiAgfTtcblxuICBjb25zdCBnZXROZXVyb25TY2FsZSA9IChuZXVyb25JZDogbnVtYmVyKSA9PiB7XG4gICAgaWYgKGFjdGl2ZU5ldXJvbiA9PT0gbmV1cm9uSWQpIHJldHVybiAxLjM1O1xuICAgIGlmIChhY3RpdmVOZXVyb24gIT09IG51bGwgJiYgbmV1cm9uc1thY3RpdmVOZXVyb25dPy5jb25uZWN0aW9ucy5pbmNsdWRlcyhuZXVyb25JZCkpIHJldHVybiAxLjE1O1xuICAgIHJldHVybiAxO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiByZWY9e2NvbnRhaW5lclJlZn0gY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgIHsvKiBCYXNlIGdyYWRpZW50IG92ZXJsYXkgKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgYmctZ3JhZGllbnQtdG8tdHIgZnJvbS1pbmRpZ28tOTUwLzEwIHZpYS10cmFuc3BhcmVudCB0by1wdXJwbGUtOTUwLzEwXCI+PC9kaXY+XG5cbiAgICAgIHsvKiBTb2Z0IGdsb2JhbCBibHVyIHRvIHJlZHVjZSBzaGFycG5lc3MgKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTBcIiBzdHlsZT17eyBmaWx0ZXI6ICdibHVyKDAuNXB4KScgfX0gLz5cblxuICAgICAgey8qIE5ldXJhbCBuZXR3b3JrIHZpc3VhbGl6YXRpb24gKi99XG4gICAgICB7aXNNb3VudGVkICYmICFwcmVmZXJzUmVkdWNlZE1vdGlvbiAmJiAoXG4gICAgICAgIDxzdmcgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCB3LWZ1bGwgaC1mdWxsXCI+XG4gICAgICAgICAgey8qIENvbm5lY3Rpb25zICovfVxuICAgICAgICAgIHtuZXVyb25zLm1hcCgobmV1cm9uKSA9PlxuICAgICAgICAgICAgbmV1cm9uLmNvbm5lY3Rpb25zLm1hcCgodGFyZ2V0SWQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gbmV1cm9uc1t0YXJnZXRJZF07XG4gICAgICAgICAgICAgIGlmICghdGFyZ2V0KSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxtb3Rpb24ubGluZVxuICAgICAgICAgICAgICAgICAga2V5PXtgJHtuZXVyb24uaWR9LSR7dGFyZ2V0SWR9YH1cbiAgICAgICAgICAgICAgICAgIHgxPXtgJHtuZXVyb24ueH0lYH1cbiAgICAgICAgICAgICAgICAgIHkxPXtgJHtuZXVyb24ueX0lYH1cbiAgICAgICAgICAgICAgICAgIHgyPXtgJHt0YXJnZXQueH0lYH1cbiAgICAgICAgICAgICAgICAgIHkyPXtgJHt0YXJnZXQueX0lYH1cbiAgICAgICAgICAgICAgICAgIHN0cm9rZT1cInJnYmEoOTksIDEwMiwgMjQxLCAwLjI1KVwiXG4gICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD1cIjAuNFwiXG4gICAgICAgICAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAgfX1cbiAgICAgICAgICAgICAgICAgIGFuaW1hdGU9e3tcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogZ2V0Q29ubmVjdGlvbk9wYWNpdHkobmV1cm9uLmlkLCB0YXJnZXRJZCksXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogYWN0aXZlTmV1cm9uID09PSBuZXVyb24uaWQgfHwgYWN0aXZlTmV1cm9uID09PSB0YXJnZXRJZFxuICAgICAgICAgICAgICAgICAgICAgID8gXCJyZ2JhKDEzOSwgOTIsIDI0NiwgMC40KVwiXG4gICAgICAgICAgICAgICAgICAgICAgOiBcInJnYmEoOTksIDEwMiwgMjQxLCAwLjI1KVwiXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbj17eyBkdXJhdGlvbjogMC4zIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKX1cblxuICAgICAgICAgIHsvKiBQdWxzZXMgKi99XG4gICAgICAgICAge3B1bHNlcy5tYXAoKHB1bHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gbmV1cm9uc1twdWxzZS5mcm9tXTtcbiAgICAgICAgICAgIGNvbnN0IHRvID0gbmV1cm9uc1twdWxzZS50b107XG4gICAgICAgICAgICBpZiAoIWZyb20gfHwgIXRvKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgY29uc3QgeCA9IGZyb20ueCArICh0by54IC0gZnJvbS54KSAqIHB1bHNlLnByb2dyZXNzO1xuICAgICAgICAgICAgY29uc3QgeSA9IGZyb20ueSArICh0by55IC0gZnJvbS55KSAqIHB1bHNlLnByb2dyZXNzO1xuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgICAgICAga2V5PXtwdWxzZS5pZH1cbiAgICAgICAgICAgICAgICBjeD17YCR7eH0lYH1cbiAgICAgICAgICAgICAgICBjeT17YCR7eX0lYH1cbiAgICAgICAgICAgICAgICByPVwiMS44XCJcbiAgICAgICAgICAgICAgICBmaWxsPVwicmdiYSgxNjgsIDg1LCAyNDcsIDAuNzUpXCJcbiAgICAgICAgICAgICAgICBvcGFjaXR5PXsxIC0gcHVsc2UucHJvZ3Jlc3MgKiAwLjV9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8YW5pbWF0ZVxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZT1cInJcIlxuICAgICAgICAgICAgICAgICAgdmFsdWVzPVwiMS44OzM7MS44XCJcbiAgICAgICAgICAgICAgICAgIGR1cj1cIjAuNnNcIlxuICAgICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2NpcmNsZT5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSl9XG5cbiAgICAgICAgICB7LyogTmV1cm9ucyAqL31cbiAgICAgICAgICB7bmV1cm9ucy5tYXAoKG5ldXJvbikgPT4gKFxuICAgICAgICAgICAgPG1vdGlvbi5nIGtleT17bmV1cm9uLmlkfT5cbiAgICAgICAgICAgICAgey8qIE91dGVyIGdsb3cgKi99XG4gICAgICAgICAgICAgIDxtb3Rpb24uY2lyY2xlXG4gICAgICAgICAgICAgICAgY3g9e2Ake25ldXJvbi54fSVgfVxuICAgICAgICAgICAgICAgIGN5PXtgJHtuZXVyb24ueX0lYH1cbiAgICAgICAgICAgICAgICByPVwiN1wiXG4gICAgICAgICAgICAgICAgZmlsbD1cInJnYmEoMTM5LCA5MiwgMjQ2LCAwLjA4KVwiXG4gICAgICAgICAgICAgICAgaW5pdGlhbD17eyBzY2FsZTogMCB9fVxuICAgICAgICAgICAgICAgIGFuaW1hdGU9e3tcbiAgICAgICAgICAgICAgICAgIHNjYWxlOiBnZXROZXVyb25TY2FsZShuZXVyb24uaWQpLFxuICAgICAgICAgICAgICAgICAgb3BhY2l0eTogYWN0aXZlTmV1cm9uID09PSBuZXVyb24uaWQgPyAwLjI1IDogMC4wOFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbj17eyBkdXJhdGlvbjogMC4zIH19XG4gICAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgICAgey8qIElubmVyIG5ldXJvbiAqL31cbiAgICAgICAgICAgICAgPG1vdGlvbi5jaXJjbGVcbiAgICAgICAgICAgICAgICBjeD17YCR7bmV1cm9uLnh9JWB9XG4gICAgICAgICAgICAgICAgY3k9e2Ake25ldXJvbi55fSVgfVxuICAgICAgICAgICAgICAgIHI9XCIyLjZcIlxuICAgICAgICAgICAgICAgIGZpbGw9XCJyZ2JhKDk5LCAxMDIsIDI0MSwgMC40NSlcIlxuICAgICAgICAgICAgICAgIGluaXRpYWw9e3sgc2NhbGU6IDAgfX1cbiAgICAgICAgICAgICAgICBhbmltYXRlPXt7XG4gICAgICAgICAgICAgICAgICBzY2FsZTogZ2V0TmV1cm9uU2NhbGUobmV1cm9uLmlkKSxcbiAgICAgICAgICAgICAgICAgIGZpbGw6IGFjdGl2ZU5ldXJvbiA9PT0gbmV1cm9uLmlkXG4gICAgICAgICAgICAgICAgICAgID8gXCJyZ2JhKDE2OCwgODUsIDI0NywgMC43NSlcIlxuICAgICAgICAgICAgICAgICAgICA6IFwicmdiYSg5OSwgMTAyLCAyNDEsIDAuNDUpXCJcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb249e3tcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjMsXG4gICAgICAgICAgICAgICAgICBkZWxheTogbmV1cm9uLnB1bHNlRGVsYXksXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxhbmltYXRlXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lPVwib3BhY2l0eVwiXG4gICAgICAgICAgICAgICAgICB2YWx1ZXM9XCIwLjU7MC43NTswLjVcIlxuICAgICAgICAgICAgICAgICAgZHVyPXtgJHszICsgbmV1cm9uLnB1bHNlRGVsYXl9c2B9XG4gICAgICAgICAgICAgICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIlxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvbW90aW9uLmNpcmNsZT5cblxuICAgICAgICAgICAgICB7LyogQ29yZSAqL31cbiAgICAgICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgICAgIGN4PXtgJHtuZXVyb24ueH0lYH1cbiAgICAgICAgICAgICAgICBjeT17YCR7bmV1cm9uLnl9JWB9XG4gICAgICAgICAgICAgICAgcj1cIjAuOVwiXG4gICAgICAgICAgICAgICAgZmlsbD1cInJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KVwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L21vdGlvbi5nPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L3N2Zz5cbiAgICAgICl9XG5cbiAgICAgIHsvKiBNb3VzZSBnbG93IGVmZmVjdCAqL31cbiAgICAgIHtpc01vdW50ZWQgJiYgIXByZWZlcnNSZWR1Y2VkTW90aW9uICYmIChcbiAgICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSB3LTY0IGgtNjQgcm91bmRlZC1mdWxsIHBvaW50ZXItZXZlbnRzLW5vbmVcIlxuICAgICAgICAgIGFuaW1hdGU9e3tcbiAgICAgICAgICAgIHg6IG1vdXNlUG9zLnggKiAoY29udGFpbmVyUmVmLmN1cnJlbnQ/Lm9mZnNldFdpZHRoIHx8IDApIC8gMTAwIC0gMTI4LFxuICAgICAgICAgICAgeTogbW91c2VQb3MueSAqIChjb250YWluZXJSZWYuY3VycmVudD8ub2Zmc2V0SGVpZ2h0IHx8IDApIC8gMTAwIC0gMTI4LFxuICAgICAgICAgIH19XG4gICAgICAgICAgdHJhbnNpdGlvbj17e1xuICAgICAgICAgICAgdHlwZTogXCJzcHJpbmdcIixcbiAgICAgICAgICAgIGRhbXBpbmc6IDMwLFxuICAgICAgICAgICAgc3RpZmZuZXNzOiAyMDAsXG4gICAgICAgICAgfX1cbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgYmFja2dyb3VuZDogXCJyYWRpYWwtZ3JhZGllbnQoY2lyY2xlLCByZ2JhKDEzOSwgOTIsIDI0NiwgMC4wOCkgMCUsIHRyYW5zcGFyZW50IDcwJSlcIixcbiAgICAgICAgICAgIGZpbHRlcjogXCJibHVyKDQwcHgpXCIsXG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgICl9XG5cbiAgICAgIHsvKiBFZGdlIGZhZGVzIGZvciBibGVuZGluZyAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgYm90dG9tLTAgbGVmdC0wIHJpZ2h0LTAgaC0zMiBiZy1ncmFkaWVudC10by10IGZyb20tc2xhdGUtOTUwIHRvLXRyYW5zcGFyZW50XCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC0wIGxlZnQtMCByaWdodC0wIGgtMjQgYmctZ3JhZGllbnQtdG8tYiBmcm9tLXNsYXRlLTk1MCB0by10cmFuc3BhcmVudFwiPjwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZU1lbW8iLCJtb3Rpb24iLCJnZW5lcmF0ZU5ldXJvbnMiLCJjb3VudE92ZXJyaWRlIiwibmV1cm9ucyIsImdyaWRTaXplIiwic3ByZWFkIiwidG90YWwiLCJpIiwiZ3JpZFgiLCJNYXRoIiwiZmxvb3IiLCJncmlkWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwicHVzaCIsImlkIiwieCIsInkiLCJjb25uZWN0aW9ucyIsInB1bHNlRGVsYXkiLCJmb3JFYWNoIiwibmV1cm9uIiwib3RoZXIiLCJqIiwiZGlzdGFuY2UiLCJzcXJ0IiwicG93IiwibGVuZ3RoIiwiTmV1cmFsTmV0d29yayIsImNvbnRhaW5lclJlZiIsIm1vdXNlUG9zIiwic2V0TW91c2VQb3MiLCJpc01vdW50ZWQiLCJzZXRJc01vdW50ZWQiLCJhY3RpdmVOZXVyb24iLCJzZXRBY3RpdmVOZXVyb24iLCJwdWxzZXMiLCJzZXRQdWxzZXMiLCJpc0NvYXJzZVBvaW50ZXIiLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsInByZWZlcnNSZWR1Y2VkTW90aW9uIiwiYW5pbWF0aW9uUmVmIiwiaGFuZGxlTW91c2VNb3ZlIiwiZSIsImN1cnJlbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImxlZnQiLCJ3aWR0aCIsImNsaWVudFkiLCJ0b3AiLCJoZWlnaHQiLCJuZWFyZXN0TmV1cm9uIiwibWluRGlzdGFuY2UiLCJvbk1vdXNlTGVhdmUiLCJjb250YWluZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxhc3RTcGF3biIsInNwYXduSW50ZXJ2YWwiLCJtYXhQdWxzZXMiLCJhbmltYXRlUHVsc2VzIiwibm93IiwiRGF0ZSIsInJhbmRvbU5ldXJvbiIsInJhbmRvbSIsInRhcmdldElkIiwicHJldiIsImZyb20iLCJ0byIsInByb2dyZXNzIiwic3RhcnRUaW1lIiwibWFwIiwicHVsc2UiLCJtaW4iLCJmaWx0ZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImhhbmRsZVZpc2liaWxpdHkiLCJkb2N1bWVudCIsImhpZGRlbiIsImdldENvbm5lY3Rpb25PcGFjaXR5IiwiZ2V0TmV1cm9uU2NhbGUiLCJuZXVyb25JZCIsImluY2x1ZGVzIiwiZGl2IiwicmVmIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJzdmciLCJ0YXJnZXQiLCJsaW5lIiwieDEiLCJ5MSIsIngyIiwieTIiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsImluaXRpYWwiLCJvcGFjaXR5IiwiYW5pbWF0ZSIsInRyYW5zaXRpb24iLCJkdXJhdGlvbiIsImNpcmNsZSIsImN4IiwiY3kiLCJyIiwiZmlsbCIsImF0dHJpYnV0ZU5hbWUiLCJ2YWx1ZXMiLCJkdXIiLCJyZXBlYXRDb3VudCIsImciLCJzY2FsZSIsImRlbGF5Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJ0eXBlIiwiZGFtcGluZyIsInN0aWZmbmVzcyIsImJhY2tncm91bmQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/NeuralNetwork.tsx\n"));

/***/ })

});